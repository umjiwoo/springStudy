# springStudy
# <H3> 22.02.04 build.gradle설정  
gradle버전에 따라 플러그인 명시 방법 다름  
buildscript{~} 하니까 빌드 안됨  
<바뀐 방법>
```
//플러그인 추가
plugins{
  id '플러그인이름' version '버전'
}
```
```
//의존성 주입
dependencies{
  implementation('모듈')
}
```
----------------------------------------------------------------------------
# <H3> 22.02.05
-단위 테스트를 진행하는 이유?  
1.서버를 실행하고 테스트 도구를 통해 응답을 요청하고 받는 수행을 반복할 필요 없어짐  
2.System.out.println()을 통해 일일이 확인할 필요 없음-테스트를 통과하면 검증된 것  
3.새로운 기능 추가 시 기존에 있던 기능이 여전히 잘 구동하는 지 확인하기 편리함-각각의 테스트 코드를 실행해보면 됨  
  
-내장 WAS 사용의 장점  
톰캣 설치의 불필요,각각 다른 서버에서 해당 프로그램을 수행할 때 외장 WAS를 쓴다면 각 서버 컴퓨터마다 WAS의 종류,버전,설정을 일치시켜야 프로그램이 구동됨  
그러나 내장 WAS를 사용한다면 언제 어디서나 같은 환경의 프로그램을 배포할 수 있게됨

------------------------------------------------------------------------------
# <H3> 22.02.07  
- JPA(Java Persistence API): 자바의 ORM(Object Relational Mapping;객체와 RDBMS 매핑) 기술
  - SQL 종속적인 개발을 지양  
  - CRUD 쿼리 직접 작성할 필요x  
  - 부모-자식 관계 표현/1:N관계 표현  
  - 상태-행위를 하나의 클래스로 관리하는 등의 객체 지향적 프로그램을 가능케 함  
    
  
- Spring Data Jpa: 스프링부트용 Spring Data Jpa 추상화 라이브러리  
    (Jpa==인터페이스;인터페이스를 구현하는 Hibernate,Eclipse Link,Data Nucleus 등과 같은 구현체 필요  
                  ;이 구현체들을 직접 다루지않고 Spring Data Jpa 모듈을 사용해 구현체를 더 쉽게 사용함)  
    - 구현체를 직접 다루지 않고 Spring Data Jpa를 사용하는 이유?  
        1. 구현체 교체의 용이성;새로운 Jpa 구현체가 생겨났을 때 Spring Data Jpa 내부에서 구현체 매핑을 지원해주므로 구현체 교체가 쉬움  
        2. 저장소 교체의 용이성;Spring Data 하위 프로젝트(Spring Data Jpa,Redis,MongoDB...)들은 기본적인 CRUD 인터페이스가 같으므로 데이터베이스 교체가 필요하다면 의존성만 교체하면 됨  
   
  
- Entity 클래스에 Setter 메소드를 만들지 않는 이유  
    :해당 클래스의 인스턴스 값들이 언제 어디서 변해야하는지 명확히 구분할 수 없기 때문  
     ;필드 값 변경이 필요한 목적을 명확하게 나타내는 메소드 작성해 줘야함  
  ->Setter 가 없는 상황에서 값을 채워 데이터베이스에 저장하는 방법?  
    :(필요 시)상황에 맞는 메소드를 호출하여 값 변경 후 생성자 또는 빌더 클래스 사용  
  
  
- Spring 웹 계층  
  -Web layer(외부 요청과 응답에 대한 전반적인 영역; 뷰,컨트롤러...)  
  
  *Data Transfer Object(DTO):계층간 데이터 교환을 위한 객체;데이터 교환만을 위해 사용하므로 로직을 갖지 않고 getter/setter 메소드만 가짐  
  
  -Service layer(컨트롤러와 데이터베이스 접근 객체를 연결)  
  
  *도메인 모델:하나의 프로그램에서 설계되어야 하는 모든 행위와 데이터를 단순화한 것  
  (Entity 객체,VO 등이 도메인 모델 영역에 해당)  
  ;Service 단에서 객체가 데이터 덩어리의 역할을 수행하지 않고 트랜잭션과 도메인 간 순서 보장의 역할을 할 수 있도록 도메인 모델에서 비즈니스 로직을 처리해줘야 함  
  
  -Repository layer(데이터베이스에 접근하는 영역)  
  
  
- 스프링에서 빈을 주입받는 방식  
    1.@Autowired  
    2.setter  
    3.생성자(recommended)
  ;객체의 불변성 확보 가능,테스트 코드 작성 용이,lombok과의 결합으로 간결한 코드 작성 가능,순환 참조 문제를 프로그램 구동 시점에서 파악 가능  
  
  
- 영속성 컨텍스트: 엔티티를 영구적으로 저장하는 환경  
  -> 엔티티가 영속성 컨텍스트에 포함되어 있다==Spring Data Jpa를 사용하는 경우 기본으로 설정되어 있는 엔티티 매니저의 활성화 상태에서 트랜잭션 안에서 DB에서 데이터를 가져오면 이 데이터는 영속성 컨텍스트가 유지된 상태  
     이 상태에서 해당 데이터 값이 변경되면 트랜잭션이 끝나는 시점에 해당 테이블에 변경이 반영됨(==더티 체킹); service 단에서 update 쿼리를 날리지 않아도 되는 이유  
  
