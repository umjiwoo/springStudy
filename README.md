# springStudy

# <H3> 22.02.04 build.gradle설정

gradle버전에 따라 플러그인 명시 방법 다름  
buildscript{~} 하니까 빌드 안됨  
<바뀐 방법>

```
//플러그인 추가
plugins{
  id '플러그인이름' version '버전'
}
```

```
//의존성 주입
dependencies{
  implementation('모듈')
}
```

----------------------------------------------------------------------------

# <H3> 22.02.05

-단위 테스트를 진행하는 이유?  
1.서버를 실행하고 테스트 도구를 통해 응답을 요청하고 받는 수행을 반복할 필요 없어짐  
2.System.out.println()을 통해 일일이 확인할 필요 없음-테스트를 통과하면 검증된 것  
3.새로운 기능 추가 시 기존에 있던 기능이 여전히 잘 구동하는 지 확인하기 편리함-각각의 테스트 코드를 실행해보면 됨

-내장 WAS 사용의 장점  
톰캣 설치의 불필요,각각 다른 서버에서 해당 프로그램을 수행할 때 외장 WAS를 쓴다면 각 서버 컴퓨터마다 WAS의 종류,버전,설정을 일치시켜야 프로그램이 구동됨  
그러나 내장 WAS를 사용한다면 언제 어디서나 같은 환경의 프로그램을 배포할 수 있게됨

------------------------------------------------------------------------------

# <H3> 22.02.07

- JPA(Java Persistence API): 자바의 ORM(Object Relational Mapping;객체와 RDBMS 매핑) 기술
    - SQL 종속적인 개발을 지양
    - CRUD 쿼리 직접 작성할 필요x
    - 부모-자식 관계 표현/1:N관계 표현
    - 상태-행위를 하나의 클래스로 관리하는 등의 객체 지향적 프로그램을 가능케 함


- Spring Data Jpa: 스프링부트용 Spring Data Jpa 추상화 라이브러리  
  (Jpa==인터페이스;인터페이스를 구현하는 Hibernate,Eclipse Link,Data Nucleus 등과 같은 구현체 필요  
  ;이 구현체들을 직접 다루지않고 Spring Data Jpa 모듈을 사용해 구현체를 더 쉽게 사용함)
    - 구현체를 직접 다루지 않고 Spring Data Jpa를 사용하는 이유?
        1. 구현체 교체의 용이성;새로운 Jpa 구현체가 생겨났을 때 Spring Data Jpa 내부에서 구현체 매핑을 지원해주므로 구현체 교체가 쉬움
        2. 저장소 교체의 용이성;Spring Data 하위 프로젝트(Spring Data Jpa,Redis,MongoDB...)들은 기본적인 CRUD 인터페이스가 같으므로 데이터베이스 교체가 필요하다면
           의존성만 교체하면 됨


- Entity 클래스에 Setter 메소드를 만들지 않는 이유  
  :해당 클래스의 인스턴스 값들이 언제 어디서 변해야하는지 명확히 구분할 수 없기 때문  
  ;필드 값 변경이 필요한 목적을 명확하게 나타내는 메소드 작성해 줘야함  
  ->Setter 가 없는 상황에서 값을 채워 데이터베이스에 저장하는 방법?  
  :(필요 시)상황에 맞는 메소드를 호출하여 값 변경 후 생성자 또는 빌더 클래스 사용


- Spring 웹 계층  
  -Web layer(외부 요청과 응답에 대한 전반적인 영역; 뷰,컨트롤러...)

  *Data Transfer Object(DTO):계층간 데이터 교환을 위한 객체;데이터 교환만을 위해 사용하므로 로직을 갖지 않고 getter/setter 메소드만 가짐

  -Service layer(컨트롤러와 데이터베이스 접근 객체를 연결)

  *도메인 모델:하나의 프로그램에서 설계되어야 하는 모든 행위와 데이터를 단순화한 것  
  (Entity 객체,VO 등이 도메인 모델 영역에 해당)  
  ;Service 단에서 객체가 데이터 덩어리의 역할을 수행하지 않고 트랜잭션과 도메인 간 순서 보장의 역할을 할 수 있도록 도메인 모델에서 비즈니스 로직을 처리해줘야 함

  -Repository layer(데이터베이스에 접근하는 영역)


- 스프링에서 빈을 주입받는 방식  
  1.@Autowired  
  2.setter  
  3.생성자(recommended)
  ;객체의 불변성 확보 가능,테스트 코드 작성 용이,lombok과의 결합으로 간결한 코드 작성 가능,순환 참조 문제를 프로그램 구동 시점에서 파악 가능


- 영속성 컨텍스트: 엔티티를 영구적으로 저장하는 환경  
  -> 엔티티가 영속성 컨텍스트에 포함되어 있다==Spring Data Jpa를 사용하는 경우 기본으로 설정되어 있는 엔티티 매니저의 활성화 상태에서 트랜잭션 안에서 DB에서 데이터를 가져오면 이 데이터는 영속성
  컨텍스트가 유지된 상태  
  이 상태에서 해당 데이터 값이 변경되면 트랜잭션이 끝나는 시점에 해당 테이블에 변경이 반영됨(==더티 체킹); service 단에서 update 쿼리를 날리지 않아도 되는 이유

----------------------------------------------------------------------------

# <H3> 22.02.09

- 각 파일별 역할  
  -indexController.java:http 메소드와 경로를 받아 화면(.mustache 파일)을 띄우도록 하는 곳  
  -*.mustache:띄어지는 화면-이 파일의 각 엘레먼트들에 의해 이벤트가 발생  
  -index.js:들어오는 이벤트 처리해주는 곳-postsApiController 로 요청 전달  
  -PostsApiController.java:화면으로부터 들어온 요청을 받아 service단으로 넘기는 부분  
  -PostService.java:JpaRepository 를 상속받음으로써 생성되었던 기본 CRUD 메소드와  
  그 외 직접 정의한 쿼리 메소드를 호출하여 사용하는 곳

----------------------------------------------------------------------------
# <H3> 22.02.11
- Enum  
  :열거형;서로 연관된 상수들의 집합  
  ->ex)이 프로젝트에서는 사용자의 권한을 관리하는 Role이라는 클래스에서 사용됨  
  
- 직렬화  
    ->자바 시스템 내부에서 사용되는 객체 또는 데이터를  
      외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술  
      ;JVM의 메모리에 힙(또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환함
  cf)역직렬화->바이트로 변환된 데이터를 다시 객체로 변환하는 기술  
  
- Serializable 인터페이스  
    ```
  public interface Serializable {}  #구현해야할 메소드 없음
    ```
  ->존재 이유?  
  - 생성한 객체를 파일로 저장하는 경우  
  - 저장한 객체를 읽어올 경우  
  - 다른 서버에서 생성한 객체를 받을 경우  
  이 Serializable 인터페이스를 구현해야함  
  
- 세션 저장 방식  
  문제->내장 WAS의 메모리(기본으로 선택되는 방식)에 세션이 저장되어 호출되어 애플리케이션 재실행 시마다 항상 초기화 되어 로그인이 풀림  
        또한 2대 이상의 서버에서 서비스 시 서버 별 톰캣 동기화 해줘야함  
  - 해결방법1) MySql같은 데이터베이스를 세션 저장소로 사용  
  - 해결방법2) Redis,Memcached같은 인메모리 데이터베이스를 세션 저장소로 사용  